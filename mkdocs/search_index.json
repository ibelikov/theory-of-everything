{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome\n\n\nHere you can find notes, articles and how-to's about Devops, CI/CD, Release Engineering and everything.\n\n\nContribute to \nci-team/theory-of-everything\n on GitHub", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome", 
            "text": "Here you can find notes, articles and how-to's about Devops, CI/CD, Release Engineering and everything.  Contribute to  ci-team/theory-of-everything  on GitHub", 
            "title": "Welcome"
        }, 
        {
            "location": "/VCS/git-workflow/", 
            "text": "Example of Git Workflow for BitBucket\n\n\nBranching strategy\n\n\nMaster branch\n\n\nThere is a \nmaster\n branch which holds current state of the project. \nmaster\n branch must provide a working state of the\ncode all the time.\n\n\nIf master is broken - development and merges to master branch are blocked until situation is resolved.\n\n\nTo keep master in a working state, direct pushes to master branch are disabled. Every change to master branch must come\nfrom a pull-requests which passes tests and gets approval from code reviewers.\n\n\nFeature branch\n\n\nEvery change is developed in a dedicated feature branch \nfeature/\nTASK-ID\n-some-meaningful-description\n.\n\n\n    ---- A ---- B ---- C ---- D ----  master\n          \\\n           \\\n            \\\n             E ---- F ----            feature/TASK-123-add-gradle-scripts\n\n\n\n\nFeature branch is merged to master via pull-request.\n\n\nRelease branch\n\n\nRelease branch is created manually from a certain \"good enough\" point on a master branch and must be named \nrelease/\nversion\n.\n\n\nRelease candidate is built from release branch.\n\n\nDirect push to release branch is forbidden. Changes to release branch come via pull-requests from bugfix-branches.\n\n\nOnce release is deployed to production, release branch needs to be merged back to \nmaster\n.\n\n\nBugfix branch\n\n\nbugfix\n-branches for \nrelease/smth\n is the same as \nfeature\n-branches for \nmaster\n.\n\n\nbugfix branch created from branch \nrelease/X.Y.Z\n can only be merged to the same \nrelease/X.Y.Z\n branch.\n\n\nNever merge it to master, feature branch or any other release branch.\n\n\nTips and Tricks\n\n\nAlways create feature branch from master\n\n\nNever create a branch from another feature branch.\n\n\nWrong:\n\n\n    ---- A ---- B ---- C ---- D ----  master\n          \\\n           \\\n            \\\n             E ---- F ----            feature/TASK-123-add-gradle-scripts\n                     \\\n                      \\\n                       \\\n                        G ----        feature/TASK-345-add-partner-XYZ\n\n\n\n\nCorrect:\n\n\n                    G ----            feature/TASK-345-add-partner-XYZ\n                   /\n                  /\n                 /\n    ---- A ---- B ---- C ---- D ----  master\n          \\\n           \\\n            \\\n             E ---- F ----            feature/TASK-123-add-gradle-scripts\n\n\n\n\nThe main goal of this rule is that we need to avoid merges and keep history as linear as possible. With merges you can\nno longer see the linear history of the changes, and can not navigate with them easily.\n\n\nThere might be the case when you have part one of a feature implemented in a branch and it is ready to merge as it\nis. But while it is still on review, you want to keep working on this new codebase.\n\n\nIn the ideal world you should wait till the feature branch is merged. The idea is that you start additional improvements\nand refactoring of the code only when it is already accepted to the mainline and you can be sure that there will be no\nnew changes. While code is on review, it might be that you will need to change it, which then will cause rewriting of\nall the new code you have written so far.\n\n\nIf it is impossible (the review is pending but you \nneed\n to keep working on the feature), the other option would be:\n\n\nStep 1. Create new branch for next part of the feature:\n\n\n    ---- A ---- B ----             master\n          \\\n           \\\n            \\\n             E ---- F                 feature/TASK-123-part-1\n                     \\\n                      \\\n                       \\\n                        G ----        feature/TASK-123-part-2\n\n\n\n\nStep 2. Create pull-request for feature/TASK-123-part-1 (the F commit) and keep working in the branch\nfeature/TASK-123-part-2 (commit G)\n\n\nStep 3. Once feature/TASK-123-part-1 is accepted, rebase feature/TASK-123-part-2 on master:\n\n\n    ---- A ---- B ---(merge-commit)- C ---- D ----            master\n          \\             /                    \\\n           \\           /                      \\\n            \\         /                        \\\n             E ---- F                           G ----        feature/TASK-123-part-2\n\n\n\n\nStep 4. Keep working on feature/TASK-123-part-2 as an independent feature branch.\n\n\nThe third step is very important as it will eliminate the complexity in the merge of feature/TASK-123-part-2 to master\nlater on.\n\n\nUse small independent commits\n\n\nIf you can split the task into series of independent commits, create independent feature-branches for each of them.\n\n\nThe smaller your feature branch is - the easier it is for review and testing. Ideally, every feature branch should\ncontain just one atomic commit. And it should be merged to master as soon as commit is ready and passed test and review.\n\n\nOk:\n\n\n    ---- A -- B -- C -- merge ---- D ----  master\n          \\              /\n           \\            /\n            \\          /\n             E ------ F                    feature/TASK-123-add-gradle-scripts-and-clean-env.yaml\n\n\n\n\nBut better:\n\n\n                              F               feature/TASK-123-clean-environment.yml\n                             / \\\n                            /   \\\n                           /     \\\n    ---- A - B - merge -- C -- merge -- D --  master\n          \\     /\n           \\   /\n            \\ /\n             E                                feature/TASK-123-add-gradle-scripts\n\n\n\n\n\nDo not wait for the end of the sprint or for full feature implementation to merge the working code.\n\n\nNever merge to feature-branch, rebase\n\n\nMerges bring complexity and increase amount of work required to track changes and manage branches. Avoid them and use\nrebase instead.\n\n\nRebase reapplies your changes in the same order you did them on top of the master branch, thus it keeps history\nstraightforward.\n\n\nGood:\n\n\n    ---- A ---- B ---- C ---- D ----  master\n          \\\n           \\\n            \\\n             E ---- F ----            feature/TASK-123-add-gradle-scripts\n\n\n    $ git checkout feature/TASK-123-add-gradle-scripts\n    $ git rebase master\n\n\n    ---- A ---- B ---- C ---- D ----  master\n                               \\\n                                \\\n                                 \\\n                                  E'---- F'----  feature/TASK-123-add-gradle-scripts\n\n\n\n\nRebase often\n\n\nThe smaller the footprint of your change is, the easier it is to handle. The earlier you spot the merge conflict, the\neasier it is to resolve.\n\n\nRebase your branch onto master at least once per day.\n\n\nUse push --force\n\n\ngit push --force\n is a dangerous command as it rewrites history of the branch.\n\n\nIt is strictly forbidden to do \npush --force\n for master and release branches, as these branches are used for\ncollaboration, and their history is critically important and must be kept consistent.\n\n\nBut for feature branches \ngit push --force\n is recommended. It is, in fact, required for \nrebase\n to work.\n\n\nFeature branch is independent and short-living branch and owned by one developer. So one can alter its history without\naffecting anyone else's work. More to that, it is critically important to keep history of feature branch clean and\nreadable, as it is targeted for review.\n\n\nThus, while you are working on a yet unmerged feature branch, use interactive rebase, squashing and amending technics to\nclean the history, modify comments and adjust their order. And then use \ngit push --force\n for this branch to publish it\nto Bitbucket.\n\n\nIf you create pull-request from a feature branch, and then change and update the branch with \npush --force\n, Bitbucket\nwill automatically update the pull-request for you.", 
            "title": "Git workflow"
        }, 
        {
            "location": "/VCS/git-workflow/#example-of-git-workflow-for-bitbucket", 
            "text": "", 
            "title": "Example of Git Workflow for BitBucket"
        }, 
        {
            "location": "/VCS/git-workflow/#branching-strategy", 
            "text": "", 
            "title": "Branching strategy"
        }, 
        {
            "location": "/VCS/git-workflow/#master-branch", 
            "text": "There is a  master  branch which holds current state of the project.  master  branch must provide a working state of the\ncode all the time.  If master is broken - development and merges to master branch are blocked until situation is resolved.  To keep master in a working state, direct pushes to master branch are disabled. Every change to master branch must come\nfrom a pull-requests which passes tests and gets approval from code reviewers.", 
            "title": "Master branch"
        }, 
        {
            "location": "/VCS/git-workflow/#feature-branch", 
            "text": "Every change is developed in a dedicated feature branch  feature/ TASK-ID -some-meaningful-description .      ---- A ---- B ---- C ---- D ----  master\n          \\\n           \\\n            \\\n             E ---- F ----            feature/TASK-123-add-gradle-scripts  Feature branch is merged to master via pull-request.", 
            "title": "Feature branch"
        }, 
        {
            "location": "/VCS/git-workflow/#release-branch", 
            "text": "Release branch is created manually from a certain \"good enough\" point on a master branch and must be named  release/ version .  Release candidate is built from release branch.  Direct push to release branch is forbidden. Changes to release branch come via pull-requests from bugfix-branches.  Once release is deployed to production, release branch needs to be merged back to  master .", 
            "title": "Release branch"
        }, 
        {
            "location": "/VCS/git-workflow/#bugfix-branch", 
            "text": "bugfix -branches for  release/smth  is the same as  feature -branches for  master .  bugfix branch created from branch  release/X.Y.Z  can only be merged to the same  release/X.Y.Z  branch.  Never merge it to master, feature branch or any other release branch.", 
            "title": "Bugfix branch"
        }, 
        {
            "location": "/VCS/git-workflow/#tips-and-tricks", 
            "text": "", 
            "title": "Tips and Tricks"
        }, 
        {
            "location": "/VCS/git-workflow/#always-create-feature-branch-from-master", 
            "text": "Never create a branch from another feature branch.  Wrong:      ---- A ---- B ---- C ---- D ----  master\n          \\\n           \\\n            \\\n             E ---- F ----            feature/TASK-123-add-gradle-scripts\n                     \\\n                      \\\n                       \\\n                        G ----        feature/TASK-345-add-partner-XYZ  Correct:                      G ----            feature/TASK-345-add-partner-XYZ\n                   /\n                  /\n                 /\n    ---- A ---- B ---- C ---- D ----  master\n          \\\n           \\\n            \\\n             E ---- F ----            feature/TASK-123-add-gradle-scripts  The main goal of this rule is that we need to avoid merges and keep history as linear as possible. With merges you can\nno longer see the linear history of the changes, and can not navigate with them easily.  There might be the case when you have part one of a feature implemented in a branch and it is ready to merge as it\nis. But while it is still on review, you want to keep working on this new codebase.  In the ideal world you should wait till the feature branch is merged. The idea is that you start additional improvements\nand refactoring of the code only when it is already accepted to the mainline and you can be sure that there will be no\nnew changes. While code is on review, it might be that you will need to change it, which then will cause rewriting of\nall the new code you have written so far.  If it is impossible (the review is pending but you  need  to keep working on the feature), the other option would be:  Step 1. Create new branch for next part of the feature:      ---- A ---- B ----             master\n          \\\n           \\\n            \\\n             E ---- F                 feature/TASK-123-part-1\n                     \\\n                      \\\n                       \\\n                        G ----        feature/TASK-123-part-2  Step 2. Create pull-request for feature/TASK-123-part-1 (the F commit) and keep working in the branch\nfeature/TASK-123-part-2 (commit G)  Step 3. Once feature/TASK-123-part-1 is accepted, rebase feature/TASK-123-part-2 on master:      ---- A ---- B ---(merge-commit)- C ---- D ----            master\n          \\             /                    \\\n           \\           /                      \\\n            \\         /                        \\\n             E ---- F                           G ----        feature/TASK-123-part-2  Step 4. Keep working on feature/TASK-123-part-2 as an independent feature branch.  The third step is very important as it will eliminate the complexity in the merge of feature/TASK-123-part-2 to master\nlater on.", 
            "title": "Always create feature branch from master"
        }, 
        {
            "location": "/VCS/git-workflow/#use-small-independent-commits", 
            "text": "If you can split the task into series of independent commits, create independent feature-branches for each of them.  The smaller your feature branch is - the easier it is for review and testing. Ideally, every feature branch should\ncontain just one atomic commit. And it should be merged to master as soon as commit is ready and passed test and review.  Ok:      ---- A -- B -- C -- merge ---- D ----  master\n          \\              /\n           \\            /\n            \\          /\n             E ------ F                    feature/TASK-123-add-gradle-scripts-and-clean-env.yaml  But better:                                F               feature/TASK-123-clean-environment.yml\n                             / \\\n                            /   \\\n                           /     \\\n    ---- A - B - merge -- C -- merge -- D --  master\n          \\     /\n           \\   /\n            \\ /\n             E                                feature/TASK-123-add-gradle-scripts  Do not wait for the end of the sprint or for full feature implementation to merge the working code.", 
            "title": "Use small independent commits"
        }, 
        {
            "location": "/VCS/git-workflow/#never-merge-to-feature-branch-rebase", 
            "text": "Merges bring complexity and increase amount of work required to track changes and manage branches. Avoid them and use\nrebase instead.  Rebase reapplies your changes in the same order you did them on top of the master branch, thus it keeps history\nstraightforward.  Good:      ---- A ---- B ---- C ---- D ----  master\n          \\\n           \\\n            \\\n             E ---- F ----            feature/TASK-123-add-gradle-scripts\n\n\n    $ git checkout feature/TASK-123-add-gradle-scripts\n    $ git rebase master\n\n\n    ---- A ---- B ---- C ---- D ----  master\n                               \\\n                                \\\n                                 \\\n                                  E'---- F'----  feature/TASK-123-add-gradle-scripts", 
            "title": "Never merge to feature-branch, rebase"
        }, 
        {
            "location": "/VCS/git-workflow/#rebase-often", 
            "text": "The smaller the footprint of your change is, the easier it is to handle. The earlier you spot the merge conflict, the\neasier it is to resolve.  Rebase your branch onto master at least once per day.", 
            "title": "Rebase often"
        }, 
        {
            "location": "/VCS/git-workflow/#use-push-force", 
            "text": "git push --force  is a dangerous command as it rewrites history of the branch.  It is strictly forbidden to do  push --force  for master and release branches, as these branches are used for\ncollaboration, and their history is critically important and must be kept consistent.  But for feature branches  git push --force  is recommended. It is, in fact, required for  rebase  to work.  Feature branch is independent and short-living branch and owned by one developer. So one can alter its history without\naffecting anyone else's work. More to that, it is critically important to keep history of feature branch clean and\nreadable, as it is targeted for review.  Thus, while you are working on a yet unmerged feature branch, use interactive rebase, squashing and amending technics to\nclean the history, modify comments and adjust their order. And then use  git push --force  for this branch to publish it\nto Bitbucket.  If you create pull-request from a feature branch, and then change and update the branch with  push --force , Bitbucket\nwill automatically update the pull-request for you.", 
            "title": "Use push --force"
        }
    ]
}